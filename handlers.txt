package main

import (
	"encoding/json"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"strconv"

	"gorm.io/gorm"
)

type App struct {
	DB  *gorm.DB
	Cfg *Config
}

func SetupRouter(db *gorm.DB, cfg *Config) http.Handler {
	app := &App{DB: db, Cfg: cfg}
	mux := http.NewServeMux()

	// auth
	mux.HandleFunc("/api/register", app.Register)
	mux.HandleFunc("/api/login", app.Login)

	// diary
	mux.HandleFunc("/api/diaries", app.RequireAuth(app.ListCreateDiaries)) // GET list, POST create
	mux.HandleFunc("/api/diaries/", app.RequireAuth(app.DiaryDetail)) // GET/PUT/DELETE with id suffix

	// todo
	mux.HandleFunc("/api/todos", app.RequireAuth(app.ListCreateTodos))
	mux.HandleFunc("/api/todos/", app.RequireAuth(app.TodoDetail))

	// upload
	mux.HandleFunc("/api/upload", app.RequireAuth(app.UploadImage))

	// static serve uploads
	fs := http.FileServer(http.Dir(cfg.UploadDir))
	mux.Handle("/uploads/", http.StripPrefix("/uploads/", fs))

	return AuthMiddleware(cfg, db)(mux)
}

func (a *App) RequireAuth(h func(w http.ResponseWriter, r *http.Request)) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		u := UserFromContext(r)
		if u == nil {
			http.Error(w, "unauthorized", http.StatusUnauthorized)
			return
		}
		h(w, r)
	}
}

// ---------- Auth Handlers ----------
type registerReq struct {
	Username string `json:"username"`
	Password string `json:"password"`
}
func (a *App) Register(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "method", http.StatusMethodNotAllowed); return
	}
	var req registerReq
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil { http.Error(w,"bad request",400); return }
	hashed, _ := HashPassword(req.Password)
	user := User{Username: req.Username, Password: hashed}
	if err := a.DB.Create(&user).Error; err != nil { http.Error(w, "create user failed", 500); return }
	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(map[string]interface{}{"id": user.ID, "username": user.Username})
}

type loginReq struct { Username, Password string `json:"username"` }
func (a *App) Login(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost { http.Error(w, "method", 405); return }
	var req loginReq
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil { http.Error(w,"bad request",400); return }
	var u User
	if err := a.DB.Where("username = ?", req.Username).First(&u).Error; err != nil { http.Error(w, "invalid credentials", 401); return }
	if err := CheckPasswordHash(u.Password, req.Password); err != nil { http.Error(w, "invalid credentials", 401); return }
	token, err := CreateJWTToken(u.ID, a.Cfg)
	if err != nil { http.Error(w, "token error", 500); return }
	json.NewEncoder(w).Encode(map[string]string{"token": token})
}

// ---------- Diary Handlers ----------
func (a *App) ListCreateDiaries(w http.ResponseWriter, r *http.Request) {
	user := UserFromContext(r)
	if r.Method == http.MethodGet {
		var diaries []Diary
		a.DB.Where("user_id = ?", user.ID).Preload("Images").Find(&diaries)
		// 解密内容并输出 PlainCache
		for i := range diaries {
			if len(a.Cfg.AESKey)>0 && len(diaries[i].ContentEnc)>0 {
				if plain, err := DecryptAESGCM(a.Cfg.AESKey, diaries[i].IV, diaries[i].ContentEnc); err == nil {
					diaries[i].PlainCache = string(plain)
				}
			}
		}
		json.NewEncoder(w).Encode(diaries)
		return
	}
	if r.Method == http.MethodPost {
		var in struct {
			Title   string `json:"title"`
			Content string `json:"content"`
		}
		if err := json.NewDecoder(r.Body).Decode(&in); err != nil { http.Error(w,"bad",400); return }
		d := Diary{UserID: user.ID, Title: in.Title}
		if len(a.Cfg.AESKey)>0 {
			cipher, iv, err := EncryptAESGCM(a.Cfg.AESKey, []byte(in.Content))
			if err == nil {
				d.ContentEnc = cipher
				d.IV = iv
			}
		} else {
			// fallback: store plain as PlainCache -> but DB doesn't have plain column; for simplicity, store in ContentEnc as plaintext bytes (not recommended)
			d.ContentEnc = []byte(in.Content)
		}
		if err := a.DB.Create(&d).Error; err != nil { http.Error(w,"db fail",500); return }
		json.NewEncoder(w).Encode(d)
		return
	}
	http.Error(w, "method not allowed", 405)
}

func (a *App) DiaryDetail(w http.ResponseWriter, r *http.Request) {
	// 路径样式: /api/diaries/{id}
	user := UserFromContext(r)
	idStr := r.URL.Path[len("/api/diaries/"):]
	id, _ := strconv.Atoi(idStr)
	var d Diary
	if err := a.DB.Preload("Images").First(&d, id).Error; err != nil { http.Error(w,"not found",404); return }
	if d.UserID != user.ID { http.Error(w, "forbidden",403); return }

	switch r.Method {
	case http.MethodGet:
		if len(a.Cfg.AESKey)>0 {
			if plain, err := DecryptAESGCM(a.Cfg.AESKey, d.IV, d.ContentEnc); err == nil { d.PlainCache = string(plain) }
		}
		json.NewEncoder(w).Encode(d)
	case http.MethodPut:
		var in struct { Title, Content string `json:"title,content"` }
		if err := json.NewDecoder(r.Body).Decode(&in); err != nil { http.Error(w,"bad",400); return }
		d.Title = in.Title
		if len(a.Cfg.AESKey)>0 {
			cipher, iv, err := EncryptAESGCM(a.Cfg.AESKey, []byte(in.Content))
			if err == nil { d.ContentEnc = cipher; d.IV = iv }
		} else { d.ContentEnc = []byte(in.Content) }
		a.DB.Save(&d)
		json.NewEncoder(w).Encode(d)
	case http.MethodDelete:
		a.DB.Delete(&d)
		w.WriteHeader(http.StatusNoContent)
	default:
		http.Error(w, "method",405)
	}
}

// ---------- Todo Handlers ----------
func (a *App) ListCreateTodos(w http.ResponseWriter, r *http.Request) {
	user := UserFromContext(r)
	if r.Method == http.MethodGet {
		var todos []Todo
		a.DB.Where("user_id = ?", user.ID).Find(&todos)
		json.NewEncoder(w).Encode(todos)
		return
	}
	if r.Method == http.MethodPost {
		var in Todo
		if err := json.NewDecoder(r.Body).Decode(&in); err != nil { http.Error(w,"bad",400); return }
		in.UserID = user.ID
		a.DB.Create(&in)
		json.NewEncoder(w).Encode(in)
		return
	}
	http.Error(w,"method",405)
}

func (a *App) TodoDetail(w http.ResponseWriter, r *http.Request) {
	user := UserFromContext(r)
	idStr := r.URL.Path[len("/api/todos/"):]
	id, _ := strconv.Atoi(idStr)
	var t Todo
	if err := a.DB.First(&t, id).Error; err != nil { http.Error(w,"not found",404); return }
	if t.UserID != user.ID { http.Error(w, "forbidden",403); return }

	switch r.Method {
	case http.MethodGet:
		json.NewEncoder(w).Encode(t)
	case http.MethodPut:
		var in Todo
		if err := json.NewDecoder(r.Body).Decode(&in); err != nil { http.Error(w,"bad",400); return }
		t.Title = in.Title
		t.Description = in.Description
		t.Done = in.Done
		t.DueDate = in.DueDate
		a.DB.Save(&t)
		json.NewEncoder(w).Encode(t)
	case http.MethodDelete:
		a.DB.Delete(&t)
		w.WriteHeader(204)
	default:
		http.Error(w, "method",405)
	}
}

// ---------- Image Upload ----------
func (a *App) UploadImage(w http.ResponseWriter, r *http.Request) {
	user := UserFromContext(r)
	if r.Method != http.MethodPost { http.Error(w,"method",405); return }
	err := r.ParseMultipartForm(10 << 20) // 10MB
	if err != nil { http.Error(w,"too big",400); return }
	file, handler, err := r.FormFile("file")
	if err != nil { http.Error(w,"file missing",400); return }
	defer file.Close()

	filename := NewFilename(handler.Filename)
	dst := filepath.Join(a.Cfg.UploadDir, filename)
	out, err := os.Create(dst)
	if err != nil { http.Error(w,"save fail",500); return }
	defer out.Close()
	_, err = io.Copy(out, file)
	if err != nil { http.Error(w,"save fail",500); return }

	// 可选 diary_id
	var diaryID *uint = nil
	if v := r.FormValue("diary_id"); v != "" {
		if id, err := strconv.Atoi(v); err == nil {
			uid := uint(id)
			diaryID = &uid
		}
	}
	img := Image{UserID: user.ID, DiaryID: diaryID, Path: "/uploads/" + filename}
	a.DB.Create(&img)
	json.NewEncoder(w).Encode(img)
}
